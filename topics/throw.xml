<chapter id="throw">
  <title>
    Throwing mechanics
  </title>

  <para>
    Running around avoiding enemies is one thing. Fighting back is
    another.
  </para>

  <para>
    It&#39;s common in video games to be able to throw something at
    your enemies, whether it&#39;s a ball of fire, an arrow, a bolt of
    lightning, or whatever else might fit the game.
  </para>

  <para>
    Unlike anything else you have programmed for your game so far,
    throwable items have a <emphasis>time to live</emphasis>. Once you
    throw an object, it&#39;s expected to travel some distance, and
    then disappear. If it&#39;s an arrow or something similar to that,
    it may disappear when it passes the edge of the screen. If
    it&#39;s a fire ball or bolt of lightning, it might fizzle out
    after some amount of time.
  </para>

  <para>
    That means that each time a throwable item is spawned, a unique
    measure of its life span must also be spawned. You can try to do
    that yourself, but as an introduction to the concept this chapter
    only demonstrates how to throw one item at a time. Only one
    throwable item may exist at one time. On one hand, this is a
    limitation to your game, but on the other hand it becomes a game
    mechanic in itself. Your player won&#39;t be able to throw 50 fire
    balls all at once since you only allow one at a time, so
    it becomes a challenge for your player to budget when they try to
    hit an enemy. Of course, behind the scenes, it also keeps your
    code simple.
  </para>

  <note>
    <para>
      If you want to try to enable more throwable items at once, you
      can try it as a challenge to yourself. However, try doing just
      one first, and then build on the knowledge you gain from this
      chapter afterwards.
  </para>
  </note>
        
<section id="throw_class">
  <title>
    Creating the Throwable class
  </title>
  
  <para>
    By now, you&#39;re familiar with the basic <code>__init__</code>
    function when spawning a new object on screen. It's the same
    function you&#39;ve used for spawning your player and your
    enemies.
  </para>

<programlisting><![CDATA[
class Throwable(pygame.sprite.Sprite):
    '''
    Spawn a throwable object
    '''
    def __init__(self,x,y,img,throw):
        pygame.sprite.Sprite.__init__(self)
        self.image = pygame.image.load(os.path.join('images',img))
        self.image.convert_alpha()
        self.image.set_colorkey(alpha)
        self.rect   = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.firing = throw
]]></programlisting>

<para>
  The primary difference in this function compared to the
  <code>__init__</code> function of your <code>Player</code> class or
  <code>Enemy</code> class is that it has a
  <varname>self.firing</varname> variable. This variable keeps track
  of whether or not a throwable object is currently alive on
  screen, so it stands to reason that when a throwable object is
  created, the variable gets set to <code>1</code>. 
</para>
</section>

<section id="throw_ttl">
  <title>Time to live</title>
  
<para>
  Next, just as with <code>Player</code> and
  <code>Enemy</code>, you need an <code>update</code> function so that
  the throwable object moves on its own once it&#39;s thrown into the
  air toward an enemy.
</para>

<para>
  The easiest way to determine the life span of a throwable object is
  to detect when it has gone off screen. Which screen edge you monitor
  depends on the physics of your throwable object.
</para>

<para>
  If your player is throwing something that travels quickly along the
  horizontal axis, like a crossbow bolt or an arrow, or a very fast
  magical force, then you want to monitor the horizontal limit of your
  game screen. This is, of course, defined by <code>screenX</code>.
</para>

<para>
  If your player is throwing something that travels vertically, or
  both horizontally and vertically, then you must monitor the vertical
  limit of your game screen. This is defined by <code>screenY</code>.
</para>

<para>
  This example assumes your throwable object goes a little forward,
  and also falls to the ground eventually. The object does not bounce
  off the ground, though, and continues to fall off the screen. You
  can try different settings to see what fits your game best.
</para>

<programlisting><![CDATA[
    def update(self,screenY):
        '''
        throw physics
        '''
        if self.rect.y < screenY: #vertical axis
            self.rect.x  += 15 #how fast it moves forward
            self.rect.y  += 5  #how fast it falls
        else:
            self.kill()     #remove throwable object
            self.firing = 0 #free up firing slot
]]></programlisting>

<para>
  To make your throwable object move faster, increase the momentum of
  the <code>self.rect</code> values.
</para>

<para>
  If the throwable object is off screen, then the object is destroyed,
  freeing up the RAM that it had occupied. In addition,
  <varname>self.firing</varname> is set back to <code>0</code> to
  allow your player to take another shot.
</para>

</section>

<section id="throw_setup">
  <title>Throwing setup</title>

  <para>
    Just as with your player and enemies, you must create a sprite
    group in your setup section to hold the throwable object. 
  </para>

  <para>
    Additionally, you must create an inactive throwable object to
    start the game with. If you don&#39;t have a throwable object when
    the game starts, then the first time a player attempts to throw
    their weapon will fail.
  </para>

  <para>
    This example assumes your player starts with fireball as a weapon,
    so each instance of a throwable object is designated by the
    <varname>fire</varname> variable. In later levels, if the player
    acquires new skills, a new variable could be introduced, using a
    different image but leveraging the same <code>Throwable</code>
    class.
  </para>
  
  <para>
    In this block of code, the first two lines are already in
    your code, so don&#39;t type them again&#58;
  </para>
  
<programlisting><![CDATA[
movingsprites = pygame.sprite.Group() #context
movingsprites.add(player)             #context
fire = Throwable(player.rect.x,player.rect.y,'fire.png',0)
firepower = pygame.sprite.Group()
]]></programlisting>

<para>
  Notice that a throwable item starts at the same location as the
  player. That makes it look like the throwable item is coming from
  the player. The first time the fireball is generated, a
  <code>0</code> is used so that <varname>self.firing</varname> shows
  as available.
</para>
</section>

<section id="throw_loop">
  <title>Throwing in the main loop</title>

  <para>
    As usual, code that doesn&#39;t appear in the main loop
    doesn&#39;t get used in the game, so there are a few things in
    your main loop that you need to add to get your throwable object
    in your game world.
  </para>

  <para>
    The first thing you need to do is add player controls. Currently,
    you have no firepower trigger. As you know, there are two states
    for a key on a keyboard&#58; the key can be down or the key can be
    up. For movement, you used both&#59; pressing down starts the
    player moving, and then the key up signal stops the player. Firing
    only needs one signal. It&#39;s a matter of taste as to which you
    use to actually trigger your throwable object.
  </para>

  <para>
    In this code block, the first two lines are for context only&#58;
  </para>
  
<programlisting><![CDATA[
            if event.key == pygame.K_UP or event.key == ord('w'):
                player.jump(platform_list)
            if event.key == pygame.K_SPACE:
                if not fire.firing:
                    fire = Throwable(player.rect.x,player.rect.y,'fire.png',1)
                    firepower.add(fire)
]]></programlisting>

<para>
  You can put this code in the <varname>KEYDOWN</varname> or the
  <varname>KEYUP</varname> section, depending on when you want your
  throwable item to be released.
</para>

<para>
  Notice that, unlike the fireball created in your setup section, you
  use a <code>1</code> to set the <varname>self.firing</varname> as
  unavailable.
</para>

<para>
  Finally, you must update and draw your throwable object. The order
  of this matters, so put this code between your existing
  <code>enemy.move</code> and <code>movingsprites.draw</code> lines.
</para>

<programlisting><![CDATA[
    enemy.move()               #context

    if fire.firing:
        fire.update(screenY)
        firepower.draw(screen)
    movingsprites.draw(screen) #context
    enemy_list.draw(screen)       #context
]]></programlisting>

<para>
  Notice that these updates are only performed if
  the <varname>self.firing</varname> variable is set to 1. If it is
  set to 0, then <varname>fire.firing</varname> is not true, and the
  updates are skipped. If you tried to do these updates no matter
  what, your game would crash because there wouldn&#39;t be a
  <code>fire</code> object to update or draw.
</para>

<para>
  Launch your game and try to throw your weapon.
</para>

</section>

<section id="throw_collision">
  <title>Detecting collisions</title>

  <para>
    If you played your game with the new throwing mechanic, you
    probably noticed that while throwing objects does work, it
    doesn&#39;t have any affect on your foes.
  </para>

  <para>
    The reason for this is that your enemies do not check for a
    collision. An enemy can be hit by your throwable object and never
    know about it.
  </para>

  <para>
    You&#39;ve already done collision detection in your Player class,
    and this is very similar. In your Enemy class, add a new
    <code>update</code> function&#58;
  </para>

<programlisting><![CDATA[
    def update(self,firepower, enemy_list):
        '''
        detect firepower collision
        '''
        fire_hit_list = pygame.sprite.spritecollide(self,firepower,False)
        for fire in fire_hit_list:
            enemy_list.remove(self)
]]></programlisting>

<para>
  The code is simple. Each enemy object checks to see if it has been
  hit by the <varname>firepower</varname> sprite group. If it has,
  then the enemy is removed from the enemy group and disappears.
</para>

<para> To integrate that function into your game, call the function in
your new firing block in the main loop&#58;
</para>

<programlisting><![CDATA[
    if fire.firing:                             # context
        fire.update(screenY)                    # context
        firepower.draw(screen)                  # context
        enemy_list.update(firepower,enemy_list) # update enemy
]]></programlisting>

<para>
  Try your game again, and clear your world of some baddies.
</para>

<note>
  <para>
    As a bonus challenge to yourself, try incrementing your player&#39;s
    score whenever an enemy is vanquished.
  </para>
</note>

</section>
</chapter>
