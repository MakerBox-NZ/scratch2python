<chapter id="dice">
  <title>
    Dice game
  </title>

  <para>
    Pygame is a collection of special Python functions and keywords
    that make it easy to create games. Before using it, you need to
    understand the common parts of code.
  </para>

  <para>
    In this chapter, you will make a text-based game in which the
    computer rolls a virtual die, and the player rolls a virtual die,
    and the one with the highest roll wins.
  </para>

  <section id="dice_prep">
    <title>
      Game prep
    </title>

    <para>
      Before writing code, it&#39;s important to think about what you intend to write, first. Many programmers actually write simple documentation for their code <emphasis>before</emphasis> writing the code itself, so that they have a goal to programme toward. Here&#39;s how the dice programme might look, if you shipped documentation along with the game&#58;
    </para>

    <programlisting>
      Start the dice game and press RETURN or ENTER to roll. The results are printed out to your screen. You are prompted to roll again or to quit.
    </programlisting>

    <para>
      It&#39;s a simple game, but the documentation tells you a lot about what you need. Can you think of the components you will need to write this game? If you need to, think about it in terms of Scratch.
    </para>

    <para>
      Ultimately, you will need these components&#58;
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Player&#58; you need a human to play the game.
	</para>
      </listitem>
      <listitem>
	<para>
	  AI&#58; the computer must roll die, too, or else the player has no one to win or lose to.
	</para>
      </listitem>
      <listitem>
	<para>
	  Random number&#58; a common six-sided die renders a random number between 1 and 6.
	</para>
      </listitem>
      <listitem>
	<para>
	  Operator&#58; simple maths can compare one number to another to see which is higher.
	</para>
      </listitem>
      <listitem>
	<para>
	  A win or lose message.
	</para>
      </listitem>
      <listitem>
	<para>
	  A prompt to play again or quit.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      Few programmes start with all of its features implemented, so your first version will only implement the basics.  
    </para>
    
  </section>

  <section id="dice_alpha">
    <title>
      Dice game alpha
    </title>

    <para>
      A common use of variables in Scratch is for keeping score or
      tracking health, so you may not have used variables much in
      Scratch. In Python, however, variables are used a lot. Any time
      you need your programme to &#34;remember&#34; something, you use
      a variable. In fact, almost all information that code works with
      is stored in variables.
    </para>

    <para>
      Variables in Python are easy to create, and easy to work
      with. In this initial version of the dice game, two variables
      are used&#58; <varname>player</varname> and
      <varname>ai</varname>.
    </para>

    <para>
      Type the following code into a new text file called <filename>dice_alpha.py</filename>&#58;
    </para>
    
<programlisting><![CDATA[
import random

player = random.randint(1,6)
ai = random.randint(1,6)

if player > ai :
    print("You win")  # notice indentation
else:
    print("You lose")
]]></programlisting>

<para>
  Launch your game to make sure it works.
</para>

<para>
  This basic version of your dice game works pretty well. It
  accomplishes the basic goals of the game, but it doesn&#39;t feel
  that much like a game. The player never gets to know what they
  rolled, or what the computer rolled, and the game ends even if the
  player would rather play again.
</para>

<para>
  This is common of the first version of software &#40;called an <emphasis>alpha</emphasis> release&#41;. Now that you are confident that you can accomplish the main part of the game, it&#39;s time to add to the programme to improve it.
</para>

  </section>

  <section id="dice_alpha">
    <title>
      Dice game beta
    </title>

    <para>
      In this section, you will make a series of improvements to your
      game so that it &#34;feels&#34; more like a game.
    </para>

    <bridgehead>
      Descriptive results
    </bridgehead>

    <para>
      Instead of just telling the player that they did or didn&#39;t
      win, it&#39;s more interesting for the player if they know what
      they rolled. Try making these changes to your code&#58;
    </para>

<programlisting><![CDATA[
player = random.randint(1,6)
print("You rolled " + player)

ai = random.randint(1,6)
print("The computer rolled " + ai)
]]></programlisting>

<para>
  If you run the game now, it crashes because Python thinks you&#39;re trying to do maths. It thinks you&#39;re trying to add the letters <code>You rolled</code> and whatever number is currently stored in the <varname>player</varname> variable.
</para>

<para>
  You must tell Python to treat the number in the <varname>player</varname> and <varname>ai</varname> variables as if it were a word in a sentence &#40;called a <emphasis>string</emphasis> by programmers&#41; rather than a number in a maths equation &#40;called an <emphasis>integer</emphasis>&#41;.
</para>

<para>
  Make these changes to your code&#58;
</para>

<programlisting><![CDATA[
player = random.randint(1,6)
print("You rolled " + str(player) )

ai = random.randint(1,6)
print("The computer rolled " + str(ai) )
]]></programlisting>

<para>
  Run your game now to see the result.
</para>

<bridgehead>
  Taking time
</bridgehead>

<para>
  Computers are very fast. Humans sometimes can be fast, but in games sometimes it&#39;s better to build suspense. You can use the <code>time</code> function of Python to slow your game down at the suspenseful parts of your game.
</para>

<programlisting><![CDATA[
import random
import time

player = random.randint(1,6)
print("You rolled " + str(player) )

ai = random.randint(1,6)
print("The computer rolls...." )
time.sleep(2)
print("The computer has rolled a " + str(player) )

if player > ai :
    print("You win")  # notice indentation
else:
    print("You lose")
]]></programlisting>

<para>
  Launch your game to test your changes.
</para>

<bridgehead>
  Tie detection
</bridgehead>

<para>
  If you play your game often enough, you will discover that even though your game appears to be working correctly, it actually has a bug in it. You game doesn&#39;t know what to do when the player and the computer roll the same number.
</para>

<para>
  To check if a value is equal to another value, Python uses
  <code>==</code>. That&#39;s <emphasis>two</emphasis> equal signs,
  not just one. If you use only one, Python thinks you&#39;re trying
  to create a new variable, but you&#39;re actually trying to do
  maths.
</para>

<para>
  You have used <code>if</code> statements in Scratch, and now you have also used an <code>if-else</code> statement in Python, but what do you use when you want to have more than just two options? Python has a keyword called <code>elif</code>, meaning <emphasis>else if</emphasis>. This makes it possible for your code to check to see <emphasis>if</emphasis> any one of some results are true, rather than just checking if <emphasis>one</emphasis> thing is true.
</para>

<para>
  modify your code like this&#58;
</para>
  
<programlisting><![CDATA[
if player > ai :
    print("You win")  # notice indentation
elif player == ai:
    print("Tie game.")
else:
    print("You lose")
]]></programlisting>

<para>
  Launch your game a few times to see if you can tie the computer&#39;s roll.
</para>

  </section>

  <section id="dice_prep">
    <title>
      Dice game final
    </title>

    <para>
      The beta release of your dice game is functional and feels more
      like a game than the alpha. For the final release, you will
      create your first Python <code>function</code>.
    </para>

    <para>
      A function is a group of code that you can call upon as a distinct unit. Functions are important because most applications have a lot of code in them, but not all of that code has to run all at once. Functions make it so you can start an application and control what happens, and when.
    </para>

    <para>
      Change your code to this&#58;
    </para>

    <programlisting><![CDATA[
import random
import time

def dice():
    player = random.randint(1,6)
    print("You rolled " + str(player) )

    ai = random.randint(1,6)
    print("The computer rolls...." )
    time.sleep(2)
    print("The computer has rolled a " + str(player) )

    if player > ai :
        print("You win")  # notice indentation
    else:
        print("You lose")

    print("Quit? Y/N")
    cont = input()

    if cont == "Y" or cont == "y":
        exit()
    elif cont == "N" or cont == "n":
        pass
    else:
        print("I did not understand that. Playing again.")

]]></programlisting>

    <para>
      In version of your game, you ask the player if they want to quit the game. If they respond with a <varname>Y</varname> or <varname>y</varname>, then Python&#39;s <code>exit</code> function is called and the game quits.
    </para>

    <para>
      More importantly, you create your own function called <code>dice</code>. The dice function doesn&#39;t run right away. In fact, if you try your game at this stage, it won&#39;t crash but it doesn&#39;t exactly run, either. To make the <code>dice</code> function actually do something, you have to call it in your code.
    </para>

    <para>
      Add this loop to the very bottom of your existing code. The
      first two lines are only for context, and to emphasize what gets
      indented and what does not. Pay very close attention to
      indentation.
    </para>

    <programlisting><![CDATA[
        else:
        print("I did not understand that. Playing again.")

    # main loop
    while True:
        print("Press return to roll your die.")
        roll = input()
        dice()
    ]]></programlisting>
    
    <para>	
      What runs first is the <code>while True</code> code block. Since
      <varname>True</varname> is always true, by definition, this code
      block always runs until Python tells it to quit.
    </para>

    <para>
      The <code>while True</code> code block is a loop. It first
      prompts the user to start the game, then it calls your
      <code>dice</code> function. That&#39;s how the game is
      started. When the dice function is over, your loop either runs
      again or it exits, depending on how the player answered the
      prompt to quit.
    </para>

    <para>
      Using a loop to run a programme is the most common way to code
      an application. The loop ensures that the application stays open
      long enough for the computer user to use functions within the
      application. Pygame uses a loop, so you&#39;ll get to practise
      with loops as you continue through this book.
    </para>

    <para>
      Now you know most of the basic parts of a computer programme. It&#39;s time to start using Pygame.
    </para>
  </section>  
</chapter>
