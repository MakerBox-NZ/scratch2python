<chapter id="score">
  <title>
    Keeping score
  </title>

  <para>
    Now that you have loot that your player can collect, there's every
    reason to keep score so that your player sees just how much loot
    they've collected.
  </para>

  <para>
    Conversely, you can also track the player&#39;s health so that
    when they hit one of the enemy's you've just created, it actually
    means something.
  </para>

  <para>
    You already have variables tracking both score and health, but it
    all happens in the background. This chapter teaches you to display
    these statistics, in a font of your choice, on the game screen,
    during game play.
  </para>

  <section id="score_font">
    <title>Choosing a font</title>

    <para>
      Before displaying text on screen, you must tell PyGame what font
      to use. Since not everyone in the world has the exact same fonts
      on their computers, it's important to bundle your font of choice
      along with your game.
    </para>

    <para>
      To bundle a font with your game, first create a new directory in
      your game folder, right along with the directory you created for
      your images. Call it <filename>fonts</filename>.
    </para>

    <para>
      Even though several fonts come with your computer, it's not
      legal to give those fonts away. It seems strange, but that's how
      the law works. If you want to ship a font with your game, you
      must find an open source or Creative Commons font that gives you
      permission to give the font away along with your game.
    </para>

    <para>
      There are several sites that specialise in free and legal
      fonts&#58;
    </para>

    <itemizedlist>
      <listitem><para>
	<ulink url="https://fontlibrary.org/">fontlibrary.org</ulink>
      </para></listitem>
      <listitem><para>
	<ulink url="https://www.fontsquirrel.com/"></ulink>
      </para></listitem>
      <listitem><para>
	<ulink url="https://www.theleagueofmoveabletype.com/">League
	of Moveable Type</ulink>
      </para></listitem>
    </itemizedlist>

    <para>
      When you find a font that you like, download it. Extract the
      ZIP or tar file, and move the <filename>.ttf</filename> or
      <filename>.otf</filename> file into the
      <filename>fonts</filename> folder in your game directory.
    </para>

    <note>
      <para>
	You aren&#39;t installing the font to your
	computer. You&#39;re just placing it in the
	<filename>fonts</filename> folder of your game so that Pygame
	can use it. You <emphasis>can</emphasis> install the font to
	your computer if you want, but it&#39;s not necessary. The
	imortant thing is to have it in your game directory.
      </para>
    </note>

    <para>
      If the font file has a complicated name with spaces or special
      characters, just rename it. The filename is completely
      arbitrary, and the simpler it is, the easier it is for you to
      type into your code.
    </para>

    <para>
      Rename your font file to <filename>score.ttf</filename> or
      <filename>score.otf</filename>, depending on what kind of font
      you downloaded.
    </para>
    
  </section>

  <section id="score_myfont">
    <title>Initializing fonts in Pygame</title>

    <para> 
      Fonts require a special module within Pygame, so import it
      along with all the other modules you import at the top of your
      code&#58;
    </para>

<programlisting><![CDATA[
import pygame
import sys
import os
import pygame.freetype # new
]]></programlisting>

<para>
  Just as Pygame itself needs to be initialized in your code, so does
  its font subsystem. In the Setup section of your game, insert a line
  to start the font subsystem&#58;
</para>

<programlisting><![CDATA[
pygame.init()
pygame.font.init() # start freetype
main = True
]]></programlisting>

<para>
  And then tell Pygame a little about your font, such as where it
  is located, and what size it should be. Then create a new variable
  called <varname>myfont</varname> to serve as your font in the
  game. All of this also appears in the Setup section&#58;
</para>

<programlisting><![CDATA[
font_path = os.path.join(os.path.dirname(os.path.realpath(__file__)),"fonts","amazdoom.ttf")
font_size = 64
myfont    = pygame.font.Font(font_path, font_size)
]]></programlisting>
  </section>

  <section id="score_display">
    <title>Displaying text in Pygame</title>

    <para>
      Now that you&#39;ve set the font, you need a function to call to
      draw the font onto the screen. This is the same principle you
      use to draw the background and platforms in your game. 
    </para>

    <para>
      First, create a function, and use the <varname>myfont</varname>
      object to create some text, setting the colour to some RGB value. This must be a global function&#59;
      it does not exist in a class.
    </para>
    
<programlisting><![CDATA[
def stats(score,health):
    text_score  = myfont.render("Score:"+str(score),  1,(11,11,155))
    text_health = myfont.render("Health:"+str(health), 1,(155,11,11 ))
]]></programlisting>

<para>
  Then blit the text as graphics onto your game screen. The
  coordinates are the x and y values of where the text should be
  drawn. Keep in mind the size of your game screen.
</para>

<programlisting><![CDATA[
    screen.blit(text_score, (4, 4))
    screen.blit(text_health, (4, 72))
]]></programlisting>

<para>
  Of course, nothing happens in your game if it's not in the Main loop&#58;
</para>

<programlisting><![CDATA[
    enemies.draw(screen)
    stats(player.score,player.health) # draw text
    pygame.display.flip()
]]></programlisting>

<para>
  Try your game. When the player collects loot, the score goes
  up. When the player gets hit by an enemy, health goes down. Success.
</para>

<para>
  There is one problem, though. When a player gets hit by an enemy,
  health goes <emphasis>way</emphasis> down, and that&#39;s just not
  fair. Here&#39;s how to fix it.
</para>
  </section>

  <section id="score_health">
    <title>Fixing the health counter</title>

    <para>
      The problem with the current health point system is that health
      is subtracted for every tick of the Pygame clock that the enemy
      is touching the player. That means that a slow moving enemy can
      take a player down to -200 health in just one encounter, and
      that&#39;s not fair. You could, of course, just give your player
      a starting health score of 10,000 and not worry about it; that
      would work, and possibly no one would mind. But there is a
      better way.
    </para>

    <para>
      Currently, your code detects when a player and an enemy
      collide. The fix for the health point problem is to detect two
      things&#58; when the player and enemy collide, and when, once
      they have collided, they <emphasis>stop</emphasis> colliding.
    </para>

    <para>
      First, in your Player class, create a variable to represent when
      a Player and enemy have collided&#58;
    </para>

     
<programlisting><![CDATA[
        self.score     = 0
        self.health    = 10
        self.damage    = 0   # player is hit
]]></programlisting>

<para>
  In the update function of your Player class,
  <emphasis>remove</emphasis> this block of code&#58;
</para>

<programlisting><![CDATA[
        for enemy in hit_list:
            self.health -= 1
            print(self.health)
]]></programlisting>

<para>
  And in its place, check for collision as long as the player is not
  currently being hit&#58;
</para>

<programlisting><![CDATA[
        if self.damage == 0:
            for enemy in hit_list:
                if not self.rect.contains(enemy):
                    self.damage = self.rect.colliderect(enemy)
]]></programlisting>

<para>
  You might see similarity in the block you deleted and the one you
  just added. They&#39;re both doing the same job, but the new code is
  more complex. Most importantly, the new code only runs if the player
  is not <emphasis>currently</emphasis> being hit already. That means
  that this code only runs once when a player and enemy collide,
  instead of 100 times, the way it used to.
</para>

<para>
  The new code uses two new Pygame functions. self.rect.contains
  checks to see if an enemy is currently within the player&#39;s
  bounding box, and self.rect.colliderect sets your new
  <varname>self.damage</varname> variable to 1 when it is true, no
  matter how many times it is true. Now even 3 seconds of getting hit
  by an enemy still looks like 1 hit to Pygame.
</para>

<para>
  Finally, add another block of code to detect when the player and the
  enemy are no longer touching. Then and only then, subtract 1 point
  of health from the player.
</para>

<programlisting><![CDATA[
        if self.damage == 1:
            idx = self.rect.collidelist(hit_list)
            if idx == -1:
                self.damage = 0   # set damage back to 0
                self.health -= 1  # subtract 1 hp
]]></programlisting>

<para>
  Notice that this new code only gets triggered if the player has been
  hit. That means this code doesn&#39;t run while your player is
  running around your game world, exploring or collecting loot. It
  only runs when the self.damage variable gets activated. 
</para>
  
<para>
  When the code does run, it uses self.rect.collidelist to see whether
  or not the player is <emphasis>still</emphasis> touching an enemy in
  your enemy list &#40;collidelist returns a -1 if it detects no
  collision&#41;. Once it is not touching an enemy, it's time to pay
  the self.damage debt&#58; deactivate the self.damage variable by
  setting it back to 0, and subtract 1 point of health. 
</para>

<para>
  Try your game now.
</para>
  </section>

<section id="score_result">
  <title>Score reaction</title>

  <para>
    Now that you have a way for your player to know their score and
    health, you can make certain events occur when your player reaches
    certain milestones. For instance, maybe there's a special loot
    item that restores some health points. And maybe a player who
    reaches 0 health points has to start back at the beginning of a
    level.
  </para>

  <para>
    You can check for these events in your code, and manipulate your
    game world accordingly. You already know how, so this book
    doesn&#39;t cover it in detail, but do try it out on your own.
  </para>
</section>

</chapter>