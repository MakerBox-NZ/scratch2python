<chapter id="move">
  <title>
    Moving your sprite
  </title>

  <para>
    A game isn&#39;t much fun if you can&#39;t move your character
    around.
  </para>

  <qandaset>
    <qandaentry>
      <question>
	<para>Which code blocks does Scratch use to provide movement
	controls to a sprite?</para>
	</question>
	<answer>
	  <para>When key is pressed, point in direction, move 10 steps.</para>
	</answer>
    </qandaentry>
  </qandaset>

  <para>
    Setting up the keys in Pygame to control your playable character
    is similar. In fact, you have already created a key to quit your
    game; the principle is the same for movement. However, getting
    your character to move is a little more complex.
  </para>
  
  <mediaobject>
    <info>
      <othercredit>
	<orgname>MakerBox</orgname>
      </othercredit>
      <othercredit>
	<orgname>MIT</orgname>
      </othercredit>
    </info>
    <alt>Movement control in Scratch</alt>
    <imageobject>
      <imagedata align="left" format="JPG"
		 fileref="topics/images/move.jpg"/>
    </imageobject>
    <textobject>
      <para>
	Movement blocks in Scratch.
      </para>
    </textobject>
  </mediaobject>

  <para>
    Start with the easy part&#58; setting up the controller keys.
  </para>

  <section id="move_keys">
    <title>
      Setting up keys for controlling your player sprite
    </title>

    <para>
      Open your Python game script in a text editor.
    </para>

  <qandaset>
    <qandaentry>
      <question>
	<para>Where should you put code that needs to run continuously
	throughout the game?</para>
	</question>
	<answer>
	  <para>In the main loop.</para>
	</answer>
    </qandaentry>
  </qandaset>

  <para>
    To make Python listen for incoming key presses, add this code to
    the main loop. There's no code to make anything happen yet, so use
    <code>print</code> statements to signal success. This is a common
    debugging technique.
  </para>

<programlisting><![CDATA[
while main == True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit(); sys.exit()
            main = False

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT or event.key == ord('a'):
                print('left')
            if event.key == pygame.K_RIGHT or event.key == ord('d'):
                print('right')
            if event.key == pygame.K_UP or event.key == ord('w'):
	        print('jump')

        if event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT or event.key == ord('a'):
                print('left stop')
            if event.key == pygame.K_RIGHT or event.key == ord('d'):
                print('right stop')
            if event.key == ord('q'):
                pygame.quit()
                sys.exit()
                main = False    
]]></programlisting>

<para>
  Launch your game using Python, and watch the terminal window for
  output as you press the <keycode>right</keycode>,
  <keycode>left</keycode>, and <keycode>up</keycode> arrows, or the
  <keycode>a</keycode>, <keycode>s</keycode>, and <keycode>w</keycode>
  keys.
</para>

<programlisting><![CDATA[
  <prompt>&#36;</prompt> <command>python</command> <arg>./your-name_game.py</arg>
  <computeroutput>left</computeroutput>
  <computeroutput>left stop</computeroutput>
  <computeroutput>right</computeroutput>
  <computeroutput>right stop</computeroutput>
  <computeroutput>jump</computeroutput>  
]]></programlisting>

<para>
  This confirms that Pygame detects key presses correctly. Now
  it&#39;s time to do the hard work of making the sprite actually
  move.
</para>
  </section>

  <section id="move_function">
    <title>
      Coding the player movement function
    </title>

    <para>
      To make your sprite move, you must create a property for your
      sprite that represents movement. When your sprite is not
      moving, this variable is set to 0.
    </para>

    <para>
      If you are animating your sprite, or decide to animate it in the
      future, you also must track frames to enable the walk cycle to stay
      on track.
    </para>

    <para>
      Create the variables in the Player class. The first two lines
      are for context, so add the last three&#58;
    </para>

<programlisting><![CDATA[
    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
        self.momentumX = 0  # move along X
        self.momentumY = 0  # move along Y
        self.frame     = 0  # count frames
]]></programlisting>

<para>
  With those variables set, it&#39;s time to code the actual
  movement. Since the Player sprite doesn&#39;t have to respond to
  control all the time, its control functions only need to be a small
  part of what the Player sprite does.
</para>

<para>
  When you want to make an object in Python do something independent
  of the rest of its code, you place your new code in a
  <firstterm>function</firstterm>. Python functions start with the
  keyword <firstterm>def</firstterm> for <emphasis>define</emphasis>.
</para>

<para>
  Make a function in your Player sprite&#39;s code to add
  <emphasis>some number</emphasis> of pixels to your sprite&#39;s
  momentum. Don&#39;t worry about how many pixels get added yet. That
  gets decided in later code.
</para>

<programlisting><![CDATA[
    def control(self,x,y):
        '''
        control player movement
        '''
        self.momentumX += x
        self.momentumY += y
]]></programlisting>

<para>
  It's built into Scratch, but when a sprite moves in Pygame, you have
  to tell Python to redraw the sprite in its new location, and where
  that new location is.
</para>

<para>
  Since the Player sprite isn&#39;t always moving, the updates only
  need to be one function within the Player code. Add this function
  after the <code>control</code> function you created earlier.
</para>

<para>
  First, create a variable for your sprite&#39;s current position. Set
  the value of this variable to the sprite&#39;s position before
  it gets moved.
</para>

<programlisting><![CDATA[
    def update(self):
        '''
	Update sprite position
        '''

        currentX = self.rect.x
]]></programlisting>

<para>
  Then create a variable of where you want the sprite to go. Set the
  value of this variable to its current position plus <emphasis>some
  number</emphasis> of pixels. How many pixels gets set later.
</para>

<para>
  Then set the new location of your sprite to the new calculated
  position.
</para>

<programlisting><![CDATA[
	nextX = currentX+self.momentumX
        self.rect.x = nextX
]]></programlisting>

<para>
  Do the same thing for the Y position&#58;
</para>

<programlisting><![CDATA[
        currentY = self.rect.y
        nextY = currentY+self.momentumY
        self.rect.y = nextY
]]></programlisting>

<para>
  For animation, advance the animation frames as long as your sprite
  is moving, and use the corresponding animation frame&#58; 
</para>

<programlisting><![CDATA[
        # moving left
        if self.momentumX < 0:
            self.frame += 1
            if self.frame > 3*afps:
                self.frame = 0
            self.image = self.images[self.frame//afps]

        # moving right
        if self.momentumX > 0:
            self.frame += 1
            if self.frame > 3*afps:
                self.frame = 0
            self.image = self.images[self.frame//afps+4]
]]></programlisting>

<para>
  All the code you&#39;ve just written needs to know how many pixels
  to add to your sprite&#39;s current position. In Scratch, you used
  the a code block to tell your Sprite how fast to move. In Python,
  you just set a variable, and then you use that variable when
  triggering the functions of your Player sprite.
</para>

<para>
  First, create the variable. In this code, the first two lines are
  for context, so just add the third line to your script&#58;
</para>

<programlisting><![CDATA[
movingsprites = pygame.sprite.Group()
movingsprites.add(player)
movesteps = 10      # how fast to move
]]></programlisting>

<para>
  Now that you have the function and the variable, use your key
  presses to trigger the function and send the variable to your
  Sprite.
</para>

<para>
  Do this by replacing the <code>print</code> statements in your main
  loop with the Player sprite&#39;s name &#40;player&#41;, the
  function &#40;.control&#41;, and how many steps along the X axis and
  Y axis you want the Sprite to move with each loop.
</para>

<programlisting><![CDATA[
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT or event.key == ord('a'):
                player.control(-movesteps,0)
            if event.key == pygame.K_RIGHT or event.key == ord('d'):
                player.control(movesteps,0)
            if event.key == pygame.K_UP or event.key == ord('w'):
                print('jump')

        if event.type == pygame.KEYUP:
            if event.key == pygame.K_LEFT or event.key == ord('a'):
                player.control(movesteps,0)
            if event.key == pygame.K_RIGHT or event.key == ord('d'):
                player.control(-movesteps,0)
            if event.key == ord('q'):
                pygame.quit()
                sys.exit()
                main = False
]]></programlisting>

<para>
  Try your game now. Warning&#58; it won&#39;t do what you expect, yet&#33;
</para>

  <qandaset>
    <qandaentry>
      <question>
	<para>Why doesn&#39;t your sprite move yet?</para>
	</question>
	<answer>
	  <para>The main loop doesn&#39;t call the <code>update</code>
	  function.</para>
	</answer>
    </qandaentry>
  </qandaset>

  <para>
    Add code to your main loop to tell Python to update the position
    of your Sprite. Add the line with the comment&#58;
  </para>

<programlisting><![CDATA[
    player.update()  # update player position
    movingsprites.draw(screen)
    pygame.display.flip()
    clock.tick(fps)
]]></programlisting>

</section>
</chapter>
