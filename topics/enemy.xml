<chapter id="enemy">
  <title>
    Going behind enemy lines
  </title>

  <para>
    Just as you technically know how to create a looting system as
    long as you know how to do platforms, you also technically all
    ready know how to implement enemies.
  </para>

    <qandaset defaultlabel="player_q1">
    <qandaentry>
      <question>
	<para>
	  How do you create a moving enemy in Scratch?
	</para>
	</question>
	<answer>
	  <para>Forever loops and movement blocks, along with
	  collision blocks so that the enemy moves back and forth
	  within a certain region of the game world.</para>
	</answer>
    </qandaentry>
    </qandaset>

    <para>
      In Scratch, you probably used a forever-loop and collisions to
      make an enemy sprite roam some section of the game world, hoping
      to collide with the hero.
    </para>

    <mediaobject>
    <info>
      <othercredit>
	<orgname>MakerBox</orgname>
      </othercredit>
      <othercredit>
	<orgname>MIT</orgname>
      </othercredit>
    </info>
    <alt>Enemy sprites in Scratch</alt>
    <imageobject>
      <imagedata align="left" width="4.3in" format="JPG"
		 fileref="images/enemy.jpg"/>
    </imageobject>
    <textobject>
      <para>
	An enemy sprites in scratch.
      </para>
    </textobject>
  </mediaobject>

      
<section id="enemy_sprite">
  <title>
    Creating the enemy sprite
  </title>
  
  <para>
    Your enemy sprite shares a lot in common with you player
    sprite. You have to make a class so that enemies can spawn, you
    have to create an update function so that enemies detect
    collisions, and you have to make a movement function so your enemy
    can roam around.
  </para>

  <para>
    Start with the class. Conceptually, it's mostly the same as your
    Player class. You set an image or series of images to it and set its
    starting position.
  </para>

  <para>
    One important addition is a counter variable. You&#39;ll need a
    counter variable later, to keep track of the enemy&#39;s movement.
  </para>

  <para>
    At the top of the Objects section of your code, create a class
    called <code>Enemy</code> with this code&#58;
  </para>

<programlisting>
class Enemy(pygame.sprite.Sprite):
    '''
    Spawn an enemy
    '''
    def __init__(self,x,y,img):
        pygame.sprite.Sprite.__init__(self)
        self.image = pygame.image.load(os.path.join('images',img))
        self.image.convert_alpha()
        self.image.set_colorkey(alpha)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.counter = 0 
</programlisting>

</section>

<section id="enemy_spawn">
  <title>Spawning an enemy</title>
  
<para>
  You can make the class useful for spawning more than just one enemy
  by allowing yourself to tell the class which image to use for the
  sprite, and where in the world the sprite should appear. This means
  that you can use this same enemy class to generate any number of
  enemy sprites anywhere in the game world. All you have to do is make
  a call to the class, tell it which image to use, along with the X
  and Y coordinates.
</para>

<para>
  Again, this is similar in principle to spawning a player sprite. In
  the Setup section of your script, add this code. The first two lines
  are for context, so just add the final three&#58;
</para>

<programlisting>
movingsprites = pygame.sprite.Group()
movingsprites.add(player)
# enemy code below
enemy   = Enemy(777,531,'owl.png') # spawn enemy
enemies = pygame.sprite.Group()    # create enemy group 
enemies.add(enemy)                 # add enemy to group
</programlisting>

<para>
  All the same rules apply to the enemy that apply to platforms or
  loot objects. They need to scroll when the player moves, and they need
  to be updated in the main loop.
</para>

<para> In your main loop, add these blocks of code. First, use the
same rules for scrolling platforms and loot. The first two lines are
for context, so just add the final two&#58;
</para>

<programlisting>
        for loot in loot_list:
            loot.rect.x -= scroll
        for enemy in enemies:
            enemy.rect.x -= scroll
</programlisting>

<para>
  To scroll in the other direction&#58;
</para>

<programlisting>
        for loot in loot_list:
            loot.rect.x += scroll
        for enemy in enemies:
            enemy.rect.x += scroll
</programlisting>

<para>
  And then draw all enemies in the enemy group to the screen. Right
  now you only have one enemy, but you can add more later if you
  want. As long as you add an enemy to the enemies group, it will get
  drawn to the screen during the main loop. The middle line in the new
  line you need to add&#58;
</para>

<programlisting>
    movingsprites.draw(screen)
    enemies.draw(screen)  # refresh enemies
    pygame.display.flip()
</programlisting>

<para>
  Launch your game. Your enemy appears in the game world at whatever X
  and Y coordinate you chose.
</para>

</section>

<section id="enemy_collision">
  <title>Hitting the enemy</title>

  <para>
    An enemy isn&#39;t much of an enemy if they have no effect on the
    player. It&#39;s common for enemies to cause damage when a player
    collides with them. The logic is exactly the same as loot. 
  </para>

  <para>
    Since you probably want to track the player&#39;s health, the
    collision check actually happens in the Player class rather than
    in the Enemy class. You can track the enemy&#39;s health, too, if
    you want. The logic and code is pretty much the same, but for now
    just track the player&#39;s health.
  </para>

  <para>
    To track player health, you must first establish a variable for
    the player&#39;s health. Add the third line to you Player class&#58;
  </para>

<programlisting>
        self.frame     = 0
        self.score     = 0
        self.health    = 10  # track health
</programlisting>

  <para>
    In the <code>update</code> function of your Player class, add this
    code block in the same area as your loot and platform collision
    checks&#58;
  </para>
  
<programlisting>
        hit_list = pygame.sprite.spritecollide(self, enemies, False)
        for enemy in hit_list:
            self.health -= 1
            print(self.health)
</programlisting>
</section>

<section id="enemy_move">
  <title>Moving the enemy</title>

  <para>
    An enemy that stands still is useful if you want, for instance,
    spikes or traps that can harm your player, but it&#39;s more of a
    challenge if the enemies move around a little.
  </para>

  <para>
    

    
<programlisting>
    def move(self):
        '''
        enemy movement
        '''
        if self.counter >= 0 and self.counter <= 100:
            self.rect.x  += 10
            self.counter += 1
        elif self.counter >= 100 and self.counter < 150:
            self.rect.x  -= 10
        else:
            self.counter = 0
            print('reset')

        self.counter += 1
</programlisting>
	
</section>
</chapter>
