<chapter id="enemy">
  <title>
    Going behind enemy lines
  </title>

  <para>
    Just as you technically know how to create a looting system as
    long as you know how to do platforms, you also technically all
    ready know how to implement enemies.
  </para>

    <qandaset>
    <qandaentry>
      <question>
	<para>
	  How do you create a moving enemy in Scratch?
	</para>
	</question>
	<answer>
	  <para>Forever loops and movement blocks, along with
	  collision blocks so that the enemy moves back and forth
	  within a certain region of the game world.</para>
	</answer>
    </qandaentry>
    </qandaset>

    <para>
      In Scratch, you probably used a forever-loop and collisions to
      make an enemy sprite roam some section of the game world, hoping
      to collide with the hero.
    </para>

    <mediaobject>
    <info>
      <othercredit>
	<orgname>MakerBox</orgname>
      </othercredit>
      <othercredit>
	<orgname>MIT</orgname>
      </othercredit>
    </info>
    <alt>Enemy sprites in Scratch</alt>
    <imageobject>
      <imagedata align="left" format="JPG"
		 fileref="topics/images/enemy.jpg"/>
    </imageobject>
    <textobject>
      <para>
	An enemy sprites in scratch.
      </para>
    </textobject>
  </mediaobject>

      
<section id="enemy_sprite">
  <title>
    Creating the enemy sprite
  </title>
  
  <para>
    Your enemy sprite shares a lot in common with you player
    sprite. You have to make a class so that enemies can spawn, you
    have to create an update function so that enemies detect
    collisions, and you have to make a movement function so your enemy
    can roam around.
  </para>

  <para>
    Start with the class. Conceptually, it's mostly the same as your
    Player class. You set an image or series of images to it and set its
    starting position.
  </para>

  <para>
    At the top of the Objects section of your code, create a class
    called <code>Enemy</code> with this code&#58;
  </para>

<programlisting><![CDATA[
class Enemy(pygame.sprite.Sprite):
    '''
    Spawn an enemy
    '''
    def __init__(self,x,y,img):
        pygame.sprite.Sprite.__init__(self)
        self.image = pygame.image.load(os.path.join('images',img))
        self.image.convert_alpha()
        self.image.set_colorkey(alpha)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
]]></programlisting>

</section>

<section id="enemy_spawn">
  <title>Spawning an enemy</title>
  
<para>
  You can make the class useful for spawning more than just one enemy
  by allowing yourself to tell the class which image to use for the
  sprite, and where in the world the sprite should appear. This means
  that you can use this same enemy class to generate any number of
  enemy sprites anywhere in the game world. All you have to do is make
  a call to the class, tell it which image to use, along with the X
  and Y coordinates.
</para>

<para>
  Again, this is similar in principle to spawning a player sprite. In
  the Setup section of your script, add this code. The first two lines
  are for context, so just add the final three&#58;
</para>

<programlisting><![CDATA[
movingsprites = pygame.sprite.Group()
movingsprites.add(player)
# enemy code below
enemy   = Enemy(777,531,'owl.png') # spawn enemy
enemies = pygame.sprite.Group()    # create enemy group 
enemies.add(enemy)                 # add enemy to group
]]></programlisting>

<para>
  All the same rules apply to the enemy that apply to platforms or
  loot objects. They need to scroll when the player moves, and they need
  to be updated in the main loop.
</para>

<para> In your main loop, add these blocks of code. First, use the
same rules for scrolling platforms and loot. The first two lines are
for context, so just add the final two&#58;
</para>

<programlisting><![CDATA[
        for loot in loot_list:
            loot.rect.x -= scroll
        for enemy in enemies:
            enemy.rect.x -= scroll
]]></programlisting>

<para>
  To scroll in the other direction&#58;
</para>

<programlisting><![CDATA[
        for loot in loot_list:
            loot.rect.x += scroll
        for enemy in enemies:
            enemy.rect.x += scroll
]]></programlisting>

<para>
  And then draw all enemies in the enemy group to the screen. Right
  now you only have one enemy, but you can add more later if you
  want. As long as you add an enemy to the enemies group, it will get
  drawn to the screen during the main loop. The middle line in the new
  line you need to add&#58;
</para>

<programlisting><![CDATA[
    movingsprites.draw(screen)
    enemies.draw(screen)  # refresh enemies
    pygame.display.flip()
]]></programlisting>

<para>
  Launch your game. Your enemy appears in the game world at whatever X
  and Y coordinate you chose.
</para>

</section>

<section id="enemy_collision">
  <title>Hitting the enemy</title>

  <para>
    An enemy isn&#39;t much of an enemy if they have no effect on the
    player. It&#39;s common for enemies to cause damage when a player
    collides with them. The logic is exactly the same as loot. 
  </para>

  <para>
    Since you probably want to track the player&#39;s health, the
    collision check actually happens in the Player class rather than
    in the Enemy class. You can track the enemy&#39;s health, too, if
    you want. The logic and code is pretty much the same, but for now
    just track the player&#39;s health.
  </para>

  <para>
    To track player health, you must first establish a variable for
    the player&#39;s health. Add the third line to you Player class&#58;
  </para>

<programlisting><![CDATA[
        self.frame     = 0
        self.score     = 0
        self.health    = 10  # track health
]]></programlisting>

  <para>
    In the <code>update</code> function of your Player class, add this
    code block in the same area as your loot and platform collision
    checks&#58;
  </para>
  
<programlisting><![CDATA[
        hit_list = pygame.sprite.spritecollide(self, enemies, False)
        for enemy in hit_list:
            self.health -= 1
            print(self.health)
]]></programlisting>
</section>

<section id="enemy_move">
  <title>Moving the enemy</title>

  <para>
    An enemy that stands still is useful if you want, for instance,
    spikes or traps that can harm your player, but it&#39;s more of a
    challenge if the enemies move around a little.
  </para>

  <para>
    Unlike a player sprite, the enemy sprite is not controlled by the
    user. Its movements must be automated.
  </para>

  <para>
    How do you get an enemy to move back and forth within the game
    world when the game world scrolls whenever the player moves?
  </para>

  <para>
    You tell your enemy sprite to take, for example, 10
    paces to the right, and then 10 paces to the left. An enemy sprite
    can&#39;t count, so you have to create a variable to keep track of
    how many paces your enemy has moved, and then program your enemy
    to move either right or left depending on the value of your
    counting variable.
  </para>

  <para>
    First, create the counter variable in your Enemy class. Add the
    last line in this code sample&#58;
  </para>

<programlisting><![CDATA[
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.counter = 0  # counter variabla
]]></programlisting>

<para>
  Next, create a <code>move</code> function in your Enemy class. Use
  an if-else loop to create what is called an <emphasis>infinite
  loop</emphasis>&#58;
</para>

<itemizedlist>
  <listitem>
    <para>
      Move right if the counter is 0 to 100.
    </para>
  </listitem>
  <listitem>
    <para>
      Move left if the counter is 100 to 200.
    </para>
  </listitem>
  <listitem>
    <para>
      Reset the counter back to 0 if the counter is greater than 200.
    </para>
  </listitem>
</itemizedlist>

<para>
  A infinite loop has no ending&#59; it loops forever because nothing
  in the loop is ever untrue. The counter, in this case, will always
  be either between 0 and 100 or 100 and 200, so the enemy sprite will
  walk right to left and right to left forever.
</para>

<programlisting><![CDATA[
    def move(self):
        '''
        enemy movement
        '''
        if self.counter >= 0 and self.counter <= 100:
            self.rect.x  += 10
        elif self.counter >= 100 and self.counter < 150:
            self.rect.x  -= 10
        else:
            self.counter = 0
            print('reset')

        self.counter += 1
]]></programlisting>

<para>
  Will this code work if you launch your game now?
</para>

<para>
  Of course not. You must call the <code>move</code> function from
  your main loop. Add the middle line from this sample code to your
  loop&#58;
</para>

<programlisting><![CDATA[
    player.update(platform_list,loot_list)
    enemy.move()  # move enemy sprite
    movingsprites.draw(screen)
]]></programlisting>  

<para>
  Launch your game and see if you can avoid your enemy. Then try
  adding some more enemies. As an exercise, see if you can think of
  how you can change how far different enemy sprites move.
</para>

</section>
</chapter>
